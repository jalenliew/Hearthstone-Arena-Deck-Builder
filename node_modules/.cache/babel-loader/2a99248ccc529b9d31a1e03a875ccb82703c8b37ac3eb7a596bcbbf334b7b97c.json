{"ast":null,"code":"'use strict';\n\nconst Events = require('events');\nconst Http = require('http');\nconst Https = require('https');\nconst Stream = require('stream');\nconst Url = require('url');\nconst Zlib = require('zlib');\nconst Boom = require('@hapi/boom');\nconst Bourne = require('@hapi/bourne');\nconst Hoek = require('@hapi/hoek');\nconst Payload = require('./payload');\nconst Recorder = require('./recorder');\nconst Tap = require('./tap');\nconst internals = {\n  jsonRegex: /^application\\/([a-z0-9.]*[+-]json|json)$/,\n  shallowOptions: ['agent', 'agents', 'beforeRedirect', 'payload', 'redirected']\n};\n\n// New instance is exported as module.exports\n\ninternals.Client = class {\n  constructor(options = {}) {\n    Hoek.assert(!options.agents || options.agents.https && options.agents.http && options.agents.httpsAllowUnauthorized, 'Option agents must include \"http\", \"https\", and \"httpsAllowUnauthorized\"');\n    this._defaults = Hoek.clone(options, {\n      shallow: internals.shallowOptions\n    });\n    this.agents = this._defaults.agents || {\n      https: new Https.Agent({\n        maxSockets: Infinity\n      }),\n      http: new Http.Agent({\n        maxSockets: Infinity\n      }),\n      httpsAllowUnauthorized: new Https.Agent({\n        maxSockets: Infinity,\n        rejectUnauthorized: false\n      })\n    };\n    if (this._defaults.events) {\n      this.events = new Events.EventEmitter();\n    }\n  }\n  defaults(options) {\n    Hoek.assert(options && typeof options === 'object', 'options must be provided to defaults');\n    options = Hoek.applyToDefaults(this._defaults, options, {\n      shallow: internals.shallowOptions\n    });\n    return new internals.Client(options);\n  }\n  request(method, url, options = {}) {\n    try {\n      options = Hoek.applyToDefaults(this._defaults, options, {\n        shallow: internals.shallowOptions\n      });\n      Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || typeof options.payload === 'object', 'options.payload must be a string, a Buffer, a Stream, or an Object');\n      Hoek.assert(internals.isNullOrUndefined(options.agent) || typeof options.rejectUnauthorized !== 'boolean', 'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');\n      Hoek.assert(internals.isNullOrUndefined(options.beforeRedirect) || typeof options.beforeRedirect === 'function', 'options.beforeRedirect must be a function');\n      Hoek.assert(internals.isNullOrUndefined(options.redirected) || typeof options.redirected === 'function', 'options.redirected must be a function');\n      Hoek.assert(options.gunzip === undefined || typeof options.gunzip === 'boolean' || options.gunzip === 'force', 'options.gunzip must be a boolean or \"force\"');\n    } catch (err) {\n      return Promise.reject(err);\n    }\n    if (options.baseUrl) {\n      url = internals.resolveUrl(options.baseUrl, url);\n      delete options.baseUrl;\n    }\n    const relay = {};\n    const req = this._request(method, url, options, relay);\n    const promise = new Promise((resolve, reject) => {\n      relay.callback = (err, res) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(res);\n        return;\n      };\n    });\n    promise.req = req;\n    return promise;\n  }\n  _request(method, url, options, relay, _trace) {\n    const uri = {};\n    if (options.socketPath) {\n      uri.socketPath = options.socketPath;\n      const parsedUri = new Url.URL(url, `unix://${options.socketPath}`);\n      internals.applyUrlToOptions(uri, {\n        host: '',\n        // host must be empty according to https://tools.ietf.org/html/rfc2616#section-14.23\n        protocol: 'http:',\n        hash: parsedUri.hash,\n        search: parsedUri.search,\n        searchParams: parsedUri.searchParams,\n        pathname: parsedUri.pathname,\n        href: parsedUri.href\n      });\n    } else {\n      uri.setHost = false;\n      const parsedUri = new Url.URL(url);\n      internals.applyUrlToOptions(uri, parsedUri);\n    }\n    uri.method = method.toUpperCase();\n    uri.headers = Object.assign({}, options.headers);\n    const hostHeader = internals.findHeader('host', uri.headers);\n    if (!hostHeader) {\n      uri.headers.host = uri.host;\n    }\n    const hasContentLength = internals.findHeader('content-length', uri.headers) !== undefined;\n    if (options.payload && typeof options.payload === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {\n      options.payload = JSON.stringify(options.payload);\n      if (!internals.findHeader('content-type', uri.headers)) {\n        uri.headers['content-type'] = 'application/json';\n      }\n    }\n    if (options.gunzip && internals.findHeader('accept-encoding', uri.headers) === undefined) {\n      uri.headers['accept-encoding'] = 'gzip';\n    }\n    const payloadSupported = uri.method !== 'GET' && uri.method !== 'HEAD' && !internals.isNullOrUndefined(options.payload);\n    if (payloadSupported && (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) && !hasContentLength) {\n      uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);\n    }\n    let redirects = options.hasOwnProperty('redirects') ? options.redirects : false; // Needed to allow 0 as valid value when passed recursively\n\n    _trace = _trace ?? [];\n    _trace.push({\n      method: uri.method,\n      url\n    });\n    const client = uri.protocol === 'https:' ? Https : Http;\n    if (options.rejectUnauthorized !== undefined && uri.protocol === 'https:') {\n      uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;\n    } else if (options.agent || options.agent === false) {\n      uri.agent = options.agent;\n    } else {\n      uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;\n    }\n    if (options.secureProtocol !== undefined) {\n      uri.secureProtocol = options.secureProtocol;\n    }\n    if (options.ciphers !== undefined) {\n      uri.ciphers = options.ciphers;\n    }\n    this._emit('preRequest', uri, options);\n    const start = Date.now();\n    const req = client.request(uri);\n    this._emit('request', req);\n    let shadow = null; // A copy of the streamed request payload when redirects are enabled\n    let timeoutId;\n    const onError = err => {\n      err.trace = _trace;\n      return finishOnce(Boom.badGateway('Client request error', err));\n    };\n    const onAbort = () => {\n      if (!req.socket) {\n        // Fake an ECONNRESET error on early abort\n\n        const error = new Error('socket hang up');\n        error.code = 'ECONNRESET';\n        finishOnce(error);\n      }\n    };\n    req.once('error', onError);\n    const onResponse = res => {\n      // Pass-through response\n\n      const statusCode = res.statusCode;\n      const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);\n      if (redirects === false || !redirectMethod) {\n        return finishOnce(null, res);\n      }\n\n      // Redirection\n\n      res.destroy();\n      if (redirects === 0) {\n        return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));\n      }\n      let location = res.headers.location;\n      if (!location) {\n        return finishOnce(Boom.badGateway('Received redirection without location', _trace));\n      }\n      if (!/^https?:/i.test(location)) {\n        location = Url.resolve(uri.href, location);\n      }\n      const redirectOptions = Hoek.clone(options, {\n        shallow: internals.shallowOptions\n      });\n      redirectOptions.payload = shadow ?? options.payload; // shadow must be ready at this point if set\n      redirectOptions.redirects = --redirects;\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        const elapsed = Date.now() - start;\n        redirectOptions.timeout = (redirectOptions.timeout - elapsed).toString(); // stringify to not drop timeout when === 0\n      }\n\n      // When redirecting to a new hostname, remove the authorization and cookie headers\n      if (redirectOptions.headers) {\n        const parsedLocation = new URL(location);\n        if (uri.hostname !== parsedLocation.hostname) {\n          for (const header of Object.keys(redirectOptions.headers)) {\n            const lowerHeader = header.toLowerCase();\n            if (lowerHeader === 'authorization' || lowerHeader === 'cookie') {\n              delete redirectOptions.headers[header];\n            }\n          }\n        }\n      }\n      const followRedirect = err => {\n        if (err) {\n          err.trace = _trace;\n          return finishOnce(Boom.badGateway('Invalid redirect', err));\n        }\n        const redirectReq = this._request(redirectMethod, location, redirectOptions, {\n          callback: finishOnce\n        }, _trace);\n        if (options.redirected) {\n          options.redirected(statusCode, location, redirectReq);\n        }\n      };\n      if (!options.beforeRedirect) {\n        return followRedirect();\n      }\n      return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, followRedirect);\n    };\n\n    // Register handlers\n\n    const finish = (err, res) => {\n      if (err) {\n        req.abort();\n      }\n      req.removeListener('response', onResponse);\n      req.removeListener('error', onError);\n      req.removeListener('abort', onAbort);\n      req.on('error', Hoek.ignore);\n      clearTimeout(timeoutId);\n      this._emit('response', err, {\n        req,\n        res,\n        start,\n        uri\n      });\n      return relay.callback(err, res);\n    };\n    const finishOnce = Hoek.once(finish);\n    req.once('response', onResponse);\n    if (options.timeout) {\n      timeoutId = setTimeout(() => finishOnce(Boom.gatewayTimeout('Client request timeout')), options.timeout);\n    }\n    req.on('abort', onAbort);\n\n    // Write payload\n\n    if (payloadSupported) {\n      if (options.payload instanceof Stream) {\n        let stream = options.payload;\n        if (redirects) {\n          const collector = new Tap();\n          collector.once('finish', () => {\n            shadow = collector.collect();\n          });\n          stream = options.payload.pipe(collector);\n        }\n        internals.deferPipeUntilSocketConnects(req, stream);\n        return req;\n      }\n      req.write(options.payload);\n    }\n\n    // Finalize request\n\n    req.end();\n    return req;\n  }\n  _emit(...args) {\n    if (this.events) {\n      this.events.emit(...args);\n    }\n  }\n  read(res, options = {}) {\n    return new Promise((resolve, reject) => {\n      this._read(res, options, (err, payload) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(payload);\n        return;\n      });\n    });\n  }\n  _read(res, options, callback) {\n    options = Hoek.applyToDefaults(this._defaults, options, {\n      shallow: internals.shallowOptions\n    });\n\n    // Finish once\n\n    let clientTimeoutId = null;\n    const finish = (err, buffer) => {\n      clearTimeout(clientTimeoutId);\n      reader.removeListener('error', onReaderError);\n      reader.removeListener('finish', onReaderFinish);\n      res.removeListener('error', onResError);\n      res.removeListener('close', onResAborted);\n      res.removeListener('aborted', onResAborted);\n      res.on('error', Hoek.ignore);\n      if (err) {\n        return callback(err);\n      }\n      if (!options.json) {\n        return callback(null, buffer);\n      }\n\n      // Parse JSON\n\n      if (options.json === 'force') {\n        return internals.tryParseBuffer(buffer, callback);\n      }\n\n      // 'strict' or true\n\n      const contentType = res.headers && internals.findHeader('content-type', res.headers) || '';\n      const mime = contentType.split(';')[0].trim().toLowerCase();\n      if (!internals.jsonRegex.test(mime)) {\n        if (options.json === 'strict') {\n          return callback(Boom.notAcceptable('The content-type is not JSON compatible'));\n        }\n        return callback(null, buffer);\n      }\n      return internals.tryParseBuffer(buffer, callback);\n    };\n    const finishOnce = Hoek.once(finish);\n    const clientTimeout = options.timeout;\n    if (clientTimeout && clientTimeout > 0) {\n      clientTimeoutId = setTimeout(() => finishOnce(Boom.clientTimeout()), clientTimeout);\n    }\n\n    // Hander errors\n\n    const onResError = err => {\n      return finishOnce(err.isBoom ? err : Boom.internal('Payload stream error', err));\n    };\n    const onResAborted = () => {\n      if (!res.complete) {\n        finishOnce(Boom.internal('Payload stream closed prematurely'));\n      }\n    };\n    res.once('error', onResError);\n    res.once('close', onResAborted);\n    res.once('aborted', onResAborted);\n\n    // Read payload\n\n    const reader = new Recorder({\n      maxBytes: options.maxBytes\n    });\n    const onReaderError = err => {\n      if (res.destroy) {\n        // GZip stream has no destroy() method\n        res.destroy();\n      }\n      return finishOnce(err);\n    };\n    reader.once('error', onReaderError);\n    const onReaderFinish = () => {\n      return finishOnce(null, reader.collect());\n    };\n    reader.once('finish', onReaderFinish);\n    if (options.gunzip) {\n      const contentEncoding = options.gunzip === 'force' ? 'gzip' : res.headers && internals.findHeader('content-encoding', res.headers) || '';\n      if (/^(x-)?gzip(\\s*,\\s*identity)?$/.test(contentEncoding)) {\n        const gunzip = Zlib.createGunzip();\n        gunzip.once('error', onReaderError);\n        res.pipe(gunzip).pipe(reader);\n        return;\n      }\n    }\n    res.pipe(reader);\n  }\n  toReadableStream(payload, encoding) {\n    return new Payload(payload, encoding);\n  }\n  parseCacheControl(field) {\n    /*\n        Cache-Control   = 1#cache-directive\n        cache-directive = token [ \"=\" ( token / quoted-string ) ]\n        token           = [^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+\n        quoted-string   = \"(?:[^\"\\\\]|\\\\.)*\"\n    */\n\n    //                             1: directive                                        =   2: token                                              3: quoted-string\n    const regex = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n    const header = {};\n    const error = field.replace(regex, ($0, $1, $2, $3) => {\n      const value = $2 || $3;\n      header[$1] = value ? value.toLowerCase() : true;\n      return '';\n    });\n    if (header['max-age']) {\n      try {\n        const maxAge = parseInt(header['max-age'], 10);\n        if (isNaN(maxAge)) {\n          return null;\n        }\n        header['max-age'] = maxAge;\n      } catch (err) {}\n    }\n    return error ? null : header;\n  }\n\n  // Shortcuts\n\n  get(uri, options) {\n    return this._shortcut('GET', uri, options);\n  }\n  post(uri, options) {\n    return this._shortcut('POST', uri, options);\n  }\n  patch(uri, options) {\n    return this._shortcut('PATCH', uri, options);\n  }\n  put(uri, options) {\n    return this._shortcut('PUT', uri, options);\n  }\n  delete(uri, options) {\n    return this._shortcut('DELETE', uri, options);\n  }\n  async _shortcut(method, uri, options = {}) {\n    const res = await this.request(method, uri, options);\n    let payload;\n    try {\n      payload = await this.read(res, options);\n    } catch (err) {\n      err.data = err.data ?? {};\n      err.data.res = res;\n      throw err;\n    }\n    if (res.statusCode < 400) {\n      return {\n        res,\n        payload\n      };\n    }\n\n    // Response error\n\n    const data = {\n      isResponseError: true,\n      headers: res.headers,\n      res,\n      payload\n    };\n    throw new Boom.Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, {\n      statusCode: res.statusCode,\n      data\n    });\n  }\n};\n\n// baseUrl needs to end in a trailing / if it contains paths that need to be preserved\n\ninternals.resolveUrl = function (baseUrl, path) {\n  if (!path) {\n    return baseUrl;\n  }\n\n  // Will default to path if it's not a relative URL\n  const url = new Url.URL(path, baseUrl);\n  return Url.format(url);\n};\ninternals.deferPipeUntilSocketConnects = function (req, stream) {\n  const onSocket = socket => {\n    if (!socket.connecting) {\n      return onSocketConnect();\n    }\n    socket.once('connect', onSocketConnect);\n  };\n  const onSocketConnect = () => {\n    stream.pipe(req);\n    stream.removeListener('error', onStreamError);\n  };\n  const onStreamError = err => {\n    req.emit('error', err);\n  };\n  req.once('socket', onSocket);\n  stream.on('error', onStreamError);\n};\ninternals.redirectMethod = function (code, method, options) {\n  switch (code) {\n    case 301:\n    case 302:\n      return options.redirectMethod || method;\n    case 303:\n      if (options.redirect303) {\n        return 'GET';\n      }\n      break;\n    case 307:\n    case 308:\n      return method;\n  }\n  return null;\n};\ninternals.tryParseBuffer = function (buffer, next) {\n  if (buffer.length === 0) {\n    return next(null, null);\n  }\n  let payload;\n  try {\n    payload = Bourne.parse(buffer.toString());\n  } catch (err) {\n    return next(Boom.badGateway(err.message, {\n      payload: buffer\n    }));\n  }\n  return next(null, payload);\n};\ninternals.findHeader = function (headerName, headers) {\n  const normalizedName = headerName.toLowerCase();\n  for (const key of Object.keys(headers)) {\n    if (key.toLowerCase() === normalizedName) {\n      return headers[key];\n    }\n  }\n};\ninternals.applyUrlToOptions = (options, url) => {\n  options.host = url.host;\n  options.origin = url.origin;\n  options.searchParams = url.searchParams;\n  options.protocol = url.protocol;\n  options.hostname = typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname;\n  options.hash = url.hash;\n  options.search = url.search;\n  options.pathname = url.pathname;\n  options.path = `${url.pathname}${url.search}`;\n  options.href = url.href;\n  if (url.port !== '') {\n    options.port = Number(url.port);\n  }\n  if (url.username || url.password) {\n    options.auth = `${url.username}:${url.password}`;\n    options.username = url.username;\n    options.password = url.password;\n  }\n  return options;\n};\ninternals.isNullOrUndefined = val => [null, undefined].includes(val);\nmodule.exports = new internals.Client();","map":{"version":3,"names":["Events","require","Http","Https","Stream","Url","Zlib","Boom","Bourne","Hoek","Payload","Recorder","Tap","internals","jsonRegex","shallowOptions","Client","constructor","options","assert","agents","https","http","httpsAllowUnauthorized","_defaults","clone","shallow","Agent","maxSockets","Infinity","rejectUnauthorized","events","EventEmitter","defaults","applyToDefaults","request","method","url","payload","undefined","isNullOrUndefined","agent","beforeRedirect","redirected","gunzip","err","Promise","reject","baseUrl","resolveUrl","relay","req","_request","promise","resolve","callback","res","_trace","uri","socketPath","parsedUri","URL","applyUrlToOptions","host","protocol","hash","search","searchParams","pathname","href","setHost","toUpperCase","headers","Object","assign","hostHeader","findHeader","hasContentLength","Buffer","isBuffer","JSON","stringify","payloadSupported","length","byteLength","redirects","hasOwnProperty","push","client","secureProtocol","ciphers","_emit","start","Date","now","shadow","timeoutId","onError","trace","finishOnce","badGateway","onAbort","socket","error","Error","code","once","onResponse","statusCode","redirectMethod","destroy","location","test","redirectOptions","clearTimeout","elapsed","timeout","toString","parsedLocation","hostname","header","keys","lowerHeader","toLowerCase","followRedirect","redirectReq","finish","abort","removeListener","on","ignore","setTimeout","gatewayTimeout","stream","collector","collect","pipe","deferPipeUntilSocketConnects","write","end","args","emit","read","_read","clientTimeoutId","buffer","reader","onReaderError","onReaderFinish","onResError","onResAborted","json","tryParseBuffer","contentType","mime","split","trim","notAcceptable","clientTimeout","isBoom","internal","complete","maxBytes","contentEncoding","createGunzip","toReadableStream","encoding","parseCacheControl","field","regex","replace","$0","$1","$2","$3","value","maxAge","parseInt","isNaN","get","_shortcut","post","patch","put","delete","data","isResponseError","statusMessage","path","format","onSocket","connecting","onSocketConnect","onStreamError","redirect303","next","parse","message","headerName","normalizedName","key","origin","startsWith","slice","port","Number","username","password","auth","val","includes","module","exports"],"sources":["C:/Programming/Hearthstone/Hearthstone-Arena-Deck-Builder/hearthstone-app/node_modules/@hapi/wreck/lib/index.js"],"sourcesContent":["'use strict';\n\nconst Events = require('events');\nconst Http = require('http');\nconst Https = require('https');\nconst Stream = require('stream');\nconst Url = require('url');\nconst Zlib = require('zlib');\n\nconst Boom = require('@hapi/boom');\nconst Bourne = require('@hapi/bourne');\nconst Hoek = require('@hapi/hoek');\n\nconst Payload = require('./payload');\nconst Recorder = require('./recorder');\nconst Tap = require('./tap');\n\n\nconst internals = {\n    jsonRegex: /^application\\/([a-z0-9.]*[+-]json|json)$/,\n    shallowOptions: ['agent', 'agents', 'beforeRedirect', 'payload', 'redirected']\n};\n\n\n// New instance is exported as module.exports\n\ninternals.Client = class {\n\n    constructor(options = {}) {\n\n        Hoek.assert(!options.agents || options.agents.https && options.agents.http && options.agents.httpsAllowUnauthorized, 'Option agents must include \"http\", \"https\", and \"httpsAllowUnauthorized\"');\n\n        this._defaults = Hoek.clone(options, { shallow: internals.shallowOptions });\n\n        this.agents = this._defaults.agents || {\n            https: new Https.Agent({ maxSockets: Infinity }),\n            http: new Http.Agent({ maxSockets: Infinity }),\n            httpsAllowUnauthorized: new Https.Agent({ maxSockets: Infinity, rejectUnauthorized: false })\n        };\n\n        if (this._defaults.events) {\n            this.events = new Events.EventEmitter();\n        }\n    }\n\n    defaults(options) {\n\n        Hoek.assert(options && typeof options === 'object', 'options must be provided to defaults');\n\n        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });\n        return new internals.Client(options);\n    }\n\n    request(method, url, options = {}) {\n\n        try {\n            options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });\n\n            Hoek.assert(options.payload === undefined || typeof options.payload === 'string' || typeof options.payload === 'object', 'options.payload must be a string, a Buffer, a Stream, or an Object');\n            Hoek.assert(internals.isNullOrUndefined(options.agent) || typeof options.rejectUnauthorized !== 'boolean', 'options.agent cannot be set to an Agent at the same time as options.rejectUnauthorized is set');\n            Hoek.assert(internals.isNullOrUndefined(options.beforeRedirect) || typeof options.beforeRedirect === 'function', 'options.beforeRedirect must be a function');\n            Hoek.assert(internals.isNullOrUndefined(options.redirected) || typeof options.redirected === 'function', 'options.redirected must be a function');\n            Hoek.assert(options.gunzip === undefined || typeof options.gunzip === 'boolean' || options.gunzip === 'force', 'options.gunzip must be a boolean or \"force\"');\n        }\n        catch (err) {\n            return Promise.reject(err);\n        }\n\n        if (options.baseUrl) {\n            url = internals.resolveUrl(options.baseUrl, url);\n            delete options.baseUrl;\n        }\n\n        const relay = {};\n        const req = this._request(method, url, options, relay);\n        const promise = new Promise((resolve, reject) => {\n\n            relay.callback = (err, res) => {\n\n                if (err) {\n                    reject(err);\n                    return;\n                }\n\n                resolve(res);\n                return;\n            };\n        });\n\n        promise.req = req;\n        return promise;\n    }\n\n    _request(method, url, options, relay, _trace) {\n\n        const uri = {};\n        if (options.socketPath) {\n            uri.socketPath = options.socketPath;\n\n            const parsedUri = new Url.URL(url, `unix://${options.socketPath}`);\n            internals.applyUrlToOptions(uri, {\n                host: '',                               // host must be empty according to https://tools.ietf.org/html/rfc2616#section-14.23\n                protocol: 'http:',\n                hash: parsedUri.hash,\n                search: parsedUri.search,\n                searchParams: parsedUri.searchParams,\n                pathname: parsedUri.pathname,\n                href: parsedUri.href\n            });\n        }\n        else {\n            uri.setHost = false;\n            const parsedUri = new Url.URL(url);\n            internals.applyUrlToOptions(uri, parsedUri);\n        }\n\n        uri.method = method.toUpperCase();\n        uri.headers = Object.assign({}, options.headers);\n\n        const hostHeader = internals.findHeader('host', uri.headers);\n\n        if (!hostHeader) {\n            uri.headers.host = uri.host;\n        }\n\n        const hasContentLength = internals.findHeader('content-length', uri.headers) !== undefined;\n\n        if (options.payload && typeof options.payload === 'object' && !(options.payload instanceof Stream) && !Buffer.isBuffer(options.payload)) {\n            options.payload = JSON.stringify(options.payload);\n            if (!internals.findHeader('content-type', uri.headers)) {\n                uri.headers['content-type'] = 'application/json';\n            }\n        }\n\n        if (options.gunzip &&\n            internals.findHeader('accept-encoding', uri.headers) === undefined) {\n\n            uri.headers['accept-encoding'] = 'gzip';\n        }\n\n        const payloadSupported = uri.method !== 'GET' && uri.method !== 'HEAD' && !internals.isNullOrUndefined(options.payload);\n        if (payloadSupported &&\n            (typeof options.payload === 'string' || Buffer.isBuffer(options.payload)) &&\n            !hasContentLength) {\n\n            uri.headers['content-length'] = Buffer.isBuffer(options.payload) ? options.payload.length : Buffer.byteLength(options.payload);\n        }\n\n        let redirects = options.hasOwnProperty('redirects') ? options.redirects : false;        // Needed to allow 0 as valid value when passed recursively\n\n        _trace = _trace ?? [];\n        _trace.push({ method: uri.method, url });\n\n        const client = uri.protocol === 'https:' ? Https : Http;\n\n        if (options.rejectUnauthorized !== undefined &&\n            uri.protocol === 'https:') {\n\n            uri.agent = options.rejectUnauthorized ? this.agents.https : this.agents.httpsAllowUnauthorized;\n        }\n        else if (options.agent ||\n            options.agent === false) {\n\n            uri.agent = options.agent;\n        }\n        else {\n            uri.agent = uri.protocol === 'https:' ? this.agents.https : this.agents.http;\n        }\n\n        if (options.secureProtocol !== undefined) {\n            uri.secureProtocol = options.secureProtocol;\n        }\n\n        if (options.ciphers !== undefined) {\n            uri.ciphers = options.ciphers;\n        }\n\n        this._emit('preRequest', uri, options);\n\n        const start = Date.now();\n        const req = client.request(uri);\n\n        this._emit('request', req);\n\n        let shadow = null;                                                                      // A copy of the streamed request payload when redirects are enabled\n        let timeoutId;\n\n        const onError = (err) => {\n\n            err.trace = _trace;\n            return finishOnce(Boom.badGateway('Client request error', err));\n        };\n\n        const onAbort = () => {\n\n            if (!req.socket) {\n                // Fake an ECONNRESET error on early abort\n\n                const error = new Error('socket hang up');\n                error.code = 'ECONNRESET';\n                finishOnce(error);\n            }\n        };\n\n        req.once('error', onError);\n\n        const onResponse = (res) => {\n\n            // Pass-through response\n\n            const statusCode = res.statusCode;\n            const redirectMethod = internals.redirectMethod(statusCode, uri.method, options);\n\n            if (redirects === false ||\n                !redirectMethod) {\n\n                return finishOnce(null, res);\n            }\n\n            // Redirection\n\n            res.destroy();\n\n            if (redirects === 0) {\n                return finishOnce(Boom.badGateway('Maximum redirections reached', _trace));\n            }\n\n            let location = res.headers.location;\n            if (!location) {\n                return finishOnce(Boom.badGateway('Received redirection without location', _trace));\n            }\n\n            if (!/^https?:/i.test(location)) {\n                location = Url.resolve(uri.href, location);\n            }\n\n            const redirectOptions = Hoek.clone(options, { shallow: internals.shallowOptions });\n            redirectOptions.payload = shadow ?? options.payload;                                    // shadow must be ready at this point if set\n            redirectOptions.redirects = --redirects;\n            if (timeoutId) {\n                clearTimeout(timeoutId);\n                const elapsed = Date.now() - start;\n                redirectOptions.timeout = (redirectOptions.timeout - elapsed).toString();           // stringify to not drop timeout when === 0\n            }\n\n            // When redirecting to a new hostname, remove the authorization and cookie headers\n            if (redirectOptions.headers) {\n                const parsedLocation = new URL(location);\n                if (uri.hostname !== parsedLocation.hostname) {\n                    for (const header of Object.keys(redirectOptions.headers)) {\n                        const lowerHeader = header.toLowerCase();\n                        if (lowerHeader === 'authorization' || lowerHeader === 'cookie') {\n                            delete redirectOptions.headers[header];\n                        }\n                    }\n                }\n            }\n\n            const followRedirect = (err) => {\n\n                if (err) {\n                    err.trace = _trace;\n                    return finishOnce(Boom.badGateway('Invalid redirect', err));\n                }\n\n                const redirectReq = this._request(redirectMethod, location, redirectOptions, { callback: finishOnce }, _trace);\n                if (options.redirected) {\n                    options.redirected(statusCode, location, redirectReq);\n                }\n            };\n\n            if (!options.beforeRedirect) {\n                return followRedirect();\n            }\n\n            return options.beforeRedirect(redirectMethod, statusCode, location, res.headers, redirectOptions, followRedirect);\n        };\n\n        // Register handlers\n\n        const finish = (err, res) => {\n\n            if (err) {\n                req.abort();\n            }\n\n            req.removeListener('response', onResponse);\n            req.removeListener('error', onError);\n            req.removeListener('abort', onAbort);\n            req.on('error', Hoek.ignore);\n\n            clearTimeout(timeoutId);\n\n            this._emit('response', err, { req, res, start, uri });\n\n            return relay.callback(err, res);\n        };\n\n        const finishOnce = Hoek.once(finish);\n\n        req.once('response', onResponse);\n\n        if (options.timeout) {\n            timeoutId = setTimeout(() => finishOnce(Boom.gatewayTimeout('Client request timeout')), options.timeout);\n        }\n\n        req.on('abort', onAbort);\n\n        // Write payload\n\n        if (payloadSupported) {\n            if (options.payload instanceof Stream) {\n                let stream = options.payload;\n\n                if (redirects) {\n                    const collector = new Tap();\n                    collector.once('finish', () => {\n\n                        shadow = collector.collect();\n                    });\n\n                    stream = options.payload.pipe(collector);\n                }\n\n                internals.deferPipeUntilSocketConnects(req, stream);\n                return req;\n            }\n\n            req.write(options.payload);\n        }\n\n        // Finalize request\n\n        req.end();\n        return req;\n    }\n\n    _emit(...args) {\n\n        if (this.events) {\n            this.events.emit(...args);\n        }\n    }\n\n    read(res, options = {}) {\n\n        return new Promise((resolve, reject) => {\n\n            this._read(res, options, (err, payload) => {\n\n                if (err) {\n                    reject(err);\n                    return;\n                }\n\n                resolve(payload);\n                return;\n            });\n        });\n    }\n\n    _read(res, options, callback) {\n\n        options = Hoek.applyToDefaults(this._defaults, options, { shallow: internals.shallowOptions });\n\n        // Finish once\n\n        let clientTimeoutId = null;\n\n        const finish = (err, buffer) => {\n\n            clearTimeout(clientTimeoutId);\n            reader.removeListener('error', onReaderError);\n            reader.removeListener('finish', onReaderFinish);\n            res.removeListener('error', onResError);\n            res.removeListener('close', onResAborted);\n            res.removeListener('aborted', onResAborted);\n            res.on('error', Hoek.ignore);\n\n            if (err) {\n                return callback(err);\n            }\n\n            if (!options.json) {\n                return callback(null, buffer);\n            }\n\n            // Parse JSON\n\n            if (options.json === 'force') {\n                return internals.tryParseBuffer(buffer, callback);\n            }\n\n            // 'strict' or true\n\n            const contentType = res.headers && internals.findHeader('content-type', res.headers) || '';\n            const mime = contentType.split(';')[0].trim().toLowerCase();\n\n            if (!internals.jsonRegex.test(mime)) {\n                if (options.json === 'strict') {\n                    return callback(Boom.notAcceptable('The content-type is not JSON compatible'));\n                }\n\n                return callback(null, buffer);\n            }\n\n            return internals.tryParseBuffer(buffer, callback);\n        };\n\n        const finishOnce = Hoek.once(finish);\n\n        const clientTimeout = options.timeout;\n        if (clientTimeout &&\n            clientTimeout > 0) {\n\n            clientTimeoutId = setTimeout(() => finishOnce(Boom.clientTimeout()), clientTimeout);\n        }\n\n        // Hander errors\n\n        const onResError = (err) => {\n\n            return finishOnce(err.isBoom ? err : Boom.internal('Payload stream error', err));\n        };\n\n        const onResAborted = () => {\n\n            if (!res.complete) {\n                finishOnce(Boom.internal('Payload stream closed prematurely'));\n            }\n        };\n\n        res.once('error', onResError);\n        res.once('close', onResAborted);\n        res.once('aborted', onResAborted);\n\n        // Read payload\n\n        const reader = new Recorder({ maxBytes: options.maxBytes });\n\n        const onReaderError = (err) => {\n\n            if (res.destroy) {                          // GZip stream has no destroy() method\n                res.destroy();\n            }\n\n            return finishOnce(err);\n        };\n\n        reader.once('error', onReaderError);\n\n        const onReaderFinish = () => {\n\n            return finishOnce(null, reader.collect());\n        };\n\n        reader.once('finish', onReaderFinish);\n\n        if (options.gunzip) {\n            const contentEncoding = options.gunzip === 'force' ?\n                'gzip' :\n                res.headers && internals.findHeader('content-encoding', res.headers) || '';\n\n            if (/^(x-)?gzip(\\s*,\\s*identity)?$/.test(contentEncoding)) {\n                const gunzip = Zlib.createGunzip();\n                gunzip.once('error', onReaderError);\n                res.pipe(gunzip).pipe(reader);\n                return;\n            }\n        }\n\n        res.pipe(reader);\n    }\n\n    toReadableStream(payload, encoding) {\n\n        return new Payload(payload, encoding);\n    }\n\n    parseCacheControl(field) {\n\n        /*\n            Cache-Control   = 1#cache-directive\n            cache-directive = token [ \"=\" ( token / quoted-string ) ]\n            token           = [^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+\n            quoted-string   = \"(?:[^\"\\\\]|\\\\.)*\"\n        */\n\n        //                             1: directive                                        =   2: token                                              3: quoted-string\n        const regex = /(?:^|(?:\\s*\\,\\s*))([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)(?:\\=(?:([^\\x00-\\x20\\(\\)<>@\\,;\\:\\\\\"\\/\\[\\]\\?\\=\\{\\}\\x7F]+)|(?:\\\"((?:[^\"\\\\]|\\\\.)*)\\\")))?/g;\n\n        const header = {};\n        const error = field.replace(regex, ($0, $1, $2, $3) => {\n\n            const value = $2 || $3;\n            header[$1] = value ? value.toLowerCase() : true;\n            return '';\n        });\n\n        if (header['max-age']) {\n            try {\n                const maxAge = parseInt(header['max-age'], 10);\n                if (isNaN(maxAge)) {\n                    return null;\n                }\n\n                header['max-age'] = maxAge;\n            }\n            catch (err) { }\n        }\n\n        return error ? null : header;\n    }\n\n    // Shortcuts\n\n    get(uri, options) {\n\n        return this._shortcut('GET', uri, options);\n    }\n\n    post(uri, options) {\n\n        return this._shortcut('POST', uri, options);\n    }\n\n    patch(uri, options) {\n\n        return this._shortcut('PATCH', uri, options);\n    }\n\n    put(uri, options) {\n\n        return this._shortcut('PUT', uri, options);\n    }\n\n    delete(uri, options) {\n\n        return this._shortcut('DELETE', uri, options);\n    }\n\n    async _shortcut(method, uri, options = {}) {\n\n        const res = await this.request(method, uri, options);\n\n        let payload;\n        try {\n            payload = await this.read(res, options);\n        }\n        catch (err) {\n            err.data = err.data ?? {};\n            err.data.res = res;\n            throw err;\n        }\n\n        if (res.statusCode < 400) {\n            return { res, payload };\n        }\n\n        // Response error\n\n        const data = {\n            isResponseError: true,\n            headers: res.headers,\n            res,\n            payload\n        };\n\n        throw new Boom.Boom(`Response Error: ${res.statusCode} ${res.statusMessage}`, { statusCode: res.statusCode, data });\n    }\n};\n\n\n// baseUrl needs to end in a trailing / if it contains paths that need to be preserved\n\ninternals.resolveUrl = function (baseUrl, path) {\n\n    if (!path) {\n        return baseUrl;\n    }\n\n    // Will default to path if it's not a relative URL\n    const url = new Url.URL(path, baseUrl);\n    return Url.format(url);\n};\n\n\ninternals.deferPipeUntilSocketConnects = function (req, stream) {\n\n    const onSocket = (socket) => {\n\n        if (!socket.connecting) {\n            return onSocketConnect();\n        }\n\n        socket.once('connect', onSocketConnect);\n    };\n\n    const onSocketConnect = () => {\n\n        stream.pipe(req);\n        stream.removeListener('error', onStreamError);\n    };\n\n    const onStreamError = (err) => {\n\n        req.emit('error', err);\n    };\n\n    req.once('socket', onSocket);\n    stream.on('error', onStreamError);\n};\n\n\ninternals.redirectMethod = function (code, method, options) {\n\n    switch (code) {\n        case 301:\n        case 302:\n            return options.redirectMethod || method;\n\n        case 303:\n            if (options.redirect303) {\n                return 'GET';\n            }\n\n            break;\n\n        case 307:\n        case 308:\n            return method;\n    }\n\n    return null;\n};\n\n\ninternals.tryParseBuffer = function (buffer, next) {\n\n    if (buffer.length === 0) {\n        return next(null, null);\n    }\n\n    let payload;\n    try {\n        payload = Bourne.parse(buffer.toString());\n    }\n    catch (err) {\n        return next(Boom.badGateway(err.message, { payload: buffer }));\n    }\n\n    return next(null, payload);\n};\n\n\ninternals.findHeader = function (headerName, headers) {\n\n    const normalizedName = headerName.toLowerCase();\n\n    for (const key of Object.keys(headers)) {\n        if (key.toLowerCase() === normalizedName) {\n            return headers[key];\n        }\n    }\n};\n\n\ninternals.applyUrlToOptions = (options, url) => {\n\n    options.host = url.host;\n    options.origin = url.origin;\n    options.searchParams = url.searchParams;\n    options.protocol = url.protocol;\n    options.hostname = typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname;\n    options.hash = url.hash;\n    options.search = url.search;\n    options.pathname = url.pathname;\n    options.path = `${url.pathname}${url.search}`;\n    options.href = url.href;\n    if (url.port !== '') {\n        options.port = Number(url.port);\n    }\n\n    if (url.username || url.password) {\n        options.auth = `${url.username}:${url.password}`;\n        options.username = url.username;\n        options.password = url.password;\n    }\n\n    return options;\n};\n\ninternals.isNullOrUndefined = (val) => [null, undefined].includes(val);\n\nmodule.exports = new internals.Client();\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMC,IAAI,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC5B,MAAME,KAAK,GAAGF,OAAO,CAAC,OAAO,CAAC;AAC9B,MAAMG,MAAM,GAAGH,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMI,GAAG,GAAGJ,OAAO,CAAC,KAAK,CAAC;AAC1B,MAAMK,IAAI,GAAGL,OAAO,CAAC,MAAM,CAAC;AAE5B,MAAMM,IAAI,GAAGN,OAAO,CAAC,YAAY,CAAC;AAClC,MAAMO,MAAM,GAAGP,OAAO,CAAC,cAAc,CAAC;AACtC,MAAMQ,IAAI,GAAGR,OAAO,CAAC,YAAY,CAAC;AAElC,MAAMS,OAAO,GAAGT,OAAO,CAAC,WAAW,CAAC;AACpC,MAAMU,QAAQ,GAAGV,OAAO,CAAC,YAAY,CAAC;AACtC,MAAMW,GAAG,GAAGX,OAAO,CAAC,OAAO,CAAC;AAG5B,MAAMY,SAAS,GAAG;EACdC,SAAS,EAAE,0CAA0C;EACrDC,cAAc,EAAE,CAAC,OAAO,EAAE,QAAQ,EAAE,gBAAgB,EAAE,SAAS,EAAE,YAAY;AACjF,CAAC;;AAGD;;AAEAF,SAAS,CAACG,MAAM,GAAG,MAAM;EAErBC,WAAWA,CAACC,OAAO,GAAG,CAAC,CAAC,EAAE;IAEtBT,IAAI,CAACU,MAAM,CAAC,CAACD,OAAO,CAACE,MAAM,IAAIF,OAAO,CAACE,MAAM,CAACC,KAAK,IAAIH,OAAO,CAACE,MAAM,CAACE,IAAI,IAAIJ,OAAO,CAACE,MAAM,CAACG,sBAAsB,EAAE,0EAA0E,CAAC;IAEhM,IAAI,CAACC,SAAS,GAAGf,IAAI,CAACgB,KAAK,CAACP,OAAO,EAAE;MAAEQ,OAAO,EAAEb,SAAS,CAACE;IAAe,CAAC,CAAC;IAE3E,IAAI,CAACK,MAAM,GAAG,IAAI,CAACI,SAAS,CAACJ,MAAM,IAAI;MACnCC,KAAK,EAAE,IAAIlB,KAAK,CAACwB,KAAK,CAAC;QAAEC,UAAU,EAAEC;MAAS,CAAC,CAAC;MAChDP,IAAI,EAAE,IAAIpB,IAAI,CAACyB,KAAK,CAAC;QAAEC,UAAU,EAAEC;MAAS,CAAC,CAAC;MAC9CN,sBAAsB,EAAE,IAAIpB,KAAK,CAACwB,KAAK,CAAC;QAAEC,UAAU,EAAEC,QAAQ;QAAEC,kBAAkB,EAAE;MAAM,CAAC;IAC/F,CAAC;IAED,IAAI,IAAI,CAACN,SAAS,CAACO,MAAM,EAAE;MACvB,IAAI,CAACA,MAAM,GAAG,IAAI/B,MAAM,CAACgC,YAAY,CAAC,CAAC;IAC3C;EACJ;EAEAC,QAAQA,CAACf,OAAO,EAAE;IAEdT,IAAI,CAACU,MAAM,CAACD,OAAO,IAAI,OAAOA,OAAO,KAAK,QAAQ,EAAE,sCAAsC,CAAC;IAE3FA,OAAO,GAAGT,IAAI,CAACyB,eAAe,CAAC,IAAI,CAACV,SAAS,EAAEN,OAAO,EAAE;MAAEQ,OAAO,EAAEb,SAAS,CAACE;IAAe,CAAC,CAAC;IAC9F,OAAO,IAAIF,SAAS,CAACG,MAAM,CAACE,OAAO,CAAC;EACxC;EAEAiB,OAAOA,CAACC,MAAM,EAAEC,GAAG,EAAEnB,OAAO,GAAG,CAAC,CAAC,EAAE;IAE/B,IAAI;MACAA,OAAO,GAAGT,IAAI,CAACyB,eAAe,CAAC,IAAI,CAACV,SAAS,EAAEN,OAAO,EAAE;QAAEQ,OAAO,EAAEb,SAAS,CAACE;MAAe,CAAC,CAAC;MAE9FN,IAAI,CAACU,MAAM,CAACD,OAAO,CAACoB,OAAO,KAAKC,SAAS,IAAI,OAAOrB,OAAO,CAACoB,OAAO,KAAK,QAAQ,IAAI,OAAOpB,OAAO,CAACoB,OAAO,KAAK,QAAQ,EAAE,oEAAoE,CAAC;MAC9L7B,IAAI,CAACU,MAAM,CAACN,SAAS,CAAC2B,iBAAiB,CAACtB,OAAO,CAACuB,KAAK,CAAC,IAAI,OAAOvB,OAAO,CAACY,kBAAkB,KAAK,SAAS,EAAE,+FAA+F,CAAC;MAC3MrB,IAAI,CAACU,MAAM,CAACN,SAAS,CAAC2B,iBAAiB,CAACtB,OAAO,CAACwB,cAAc,CAAC,IAAI,OAAOxB,OAAO,CAACwB,cAAc,KAAK,UAAU,EAAE,2CAA2C,CAAC;MAC7JjC,IAAI,CAACU,MAAM,CAACN,SAAS,CAAC2B,iBAAiB,CAACtB,OAAO,CAACyB,UAAU,CAAC,IAAI,OAAOzB,OAAO,CAACyB,UAAU,KAAK,UAAU,EAAE,uCAAuC,CAAC;MACjJlC,IAAI,CAACU,MAAM,CAACD,OAAO,CAAC0B,MAAM,KAAKL,SAAS,IAAI,OAAOrB,OAAO,CAAC0B,MAAM,KAAK,SAAS,IAAI1B,OAAO,CAAC0B,MAAM,KAAK,OAAO,EAAE,6CAA6C,CAAC;IACjK,CAAC,CACD,OAAOC,GAAG,EAAE;MACR,OAAOC,OAAO,CAACC,MAAM,CAACF,GAAG,CAAC;IAC9B;IAEA,IAAI3B,OAAO,CAAC8B,OAAO,EAAE;MACjBX,GAAG,GAAGxB,SAAS,CAACoC,UAAU,CAAC/B,OAAO,CAAC8B,OAAO,EAAEX,GAAG,CAAC;MAChD,OAAOnB,OAAO,CAAC8B,OAAO;IAC1B;IAEA,MAAME,KAAK,GAAG,CAAC,CAAC;IAChB,MAAMC,GAAG,GAAG,IAAI,CAACC,QAAQ,CAAChB,MAAM,EAAEC,GAAG,EAAEnB,OAAO,EAAEgC,KAAK,CAAC;IACtD,MAAMG,OAAO,GAAG,IAAIP,OAAO,CAAC,CAACQ,OAAO,EAAEP,MAAM,KAAK;MAE7CG,KAAK,CAACK,QAAQ,GAAG,CAACV,GAAG,EAAEW,GAAG,KAAK;QAE3B,IAAIX,GAAG,EAAE;UACLE,MAAM,CAACF,GAAG,CAAC;UACX;QACJ;QAEAS,OAAO,CAACE,GAAG,CAAC;QACZ;MACJ,CAAC;IACL,CAAC,CAAC;IAEFH,OAAO,CAACF,GAAG,GAAGA,GAAG;IACjB,OAAOE,OAAO;EAClB;EAEAD,QAAQA,CAAChB,MAAM,EAAEC,GAAG,EAAEnB,OAAO,EAAEgC,KAAK,EAAEO,MAAM,EAAE;IAE1C,MAAMC,GAAG,GAAG,CAAC,CAAC;IACd,IAAIxC,OAAO,CAACyC,UAAU,EAAE;MACpBD,GAAG,CAACC,UAAU,GAAGzC,OAAO,CAACyC,UAAU;MAEnC,MAAMC,SAAS,GAAG,IAAIvD,GAAG,CAACwD,GAAG,CAACxB,GAAG,EAAG,UAASnB,OAAO,CAACyC,UAAW,EAAC,CAAC;MAClE9C,SAAS,CAACiD,iBAAiB,CAACJ,GAAG,EAAE;QAC7BK,IAAI,EAAE,EAAE;QAAgC;QACxCC,QAAQ,EAAE,OAAO;QACjBC,IAAI,EAAEL,SAAS,CAACK,IAAI;QACpBC,MAAM,EAAEN,SAAS,CAACM,MAAM;QACxBC,YAAY,EAAEP,SAAS,CAACO,YAAY;QACpCC,QAAQ,EAAER,SAAS,CAACQ,QAAQ;QAC5BC,IAAI,EAAET,SAAS,CAACS;MACpB,CAAC,CAAC;IACN,CAAC,MACI;MACDX,GAAG,CAACY,OAAO,GAAG,KAAK;MACnB,MAAMV,SAAS,GAAG,IAAIvD,GAAG,CAACwD,GAAG,CAACxB,GAAG,CAAC;MAClCxB,SAAS,CAACiD,iBAAiB,CAACJ,GAAG,EAAEE,SAAS,CAAC;IAC/C;IAEAF,GAAG,CAACtB,MAAM,GAAGA,MAAM,CAACmC,WAAW,CAAC,CAAC;IACjCb,GAAG,CAACc,OAAO,GAAGC,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAExD,OAAO,CAACsD,OAAO,CAAC;IAEhD,MAAMG,UAAU,GAAG9D,SAAS,CAAC+D,UAAU,CAAC,MAAM,EAAElB,GAAG,CAACc,OAAO,CAAC;IAE5D,IAAI,CAACG,UAAU,EAAE;MACbjB,GAAG,CAACc,OAAO,CAACT,IAAI,GAAGL,GAAG,CAACK,IAAI;IAC/B;IAEA,MAAMc,gBAAgB,GAAGhE,SAAS,CAAC+D,UAAU,CAAC,gBAAgB,EAAElB,GAAG,CAACc,OAAO,CAAC,KAAKjC,SAAS;IAE1F,IAAIrB,OAAO,CAACoB,OAAO,IAAI,OAAOpB,OAAO,CAACoB,OAAO,KAAK,QAAQ,IAAI,EAAEpB,OAAO,CAACoB,OAAO,YAAYlC,MAAM,CAAC,IAAI,CAAC0E,MAAM,CAACC,QAAQ,CAAC7D,OAAO,CAACoB,OAAO,CAAC,EAAE;MACrIpB,OAAO,CAACoB,OAAO,GAAG0C,IAAI,CAACC,SAAS,CAAC/D,OAAO,CAACoB,OAAO,CAAC;MACjD,IAAI,CAACzB,SAAS,CAAC+D,UAAU,CAAC,cAAc,EAAElB,GAAG,CAACc,OAAO,CAAC,EAAE;QACpDd,GAAG,CAACc,OAAO,CAAC,cAAc,CAAC,GAAG,kBAAkB;MACpD;IACJ;IAEA,IAAItD,OAAO,CAAC0B,MAAM,IACd/B,SAAS,CAAC+D,UAAU,CAAC,iBAAiB,EAAElB,GAAG,CAACc,OAAO,CAAC,KAAKjC,SAAS,EAAE;MAEpEmB,GAAG,CAACc,OAAO,CAAC,iBAAiB,CAAC,GAAG,MAAM;IAC3C;IAEA,MAAMU,gBAAgB,GAAGxB,GAAG,CAACtB,MAAM,KAAK,KAAK,IAAIsB,GAAG,CAACtB,MAAM,KAAK,MAAM,IAAI,CAACvB,SAAS,CAAC2B,iBAAiB,CAACtB,OAAO,CAACoB,OAAO,CAAC;IACvH,IAAI4C,gBAAgB,KACf,OAAOhE,OAAO,CAACoB,OAAO,KAAK,QAAQ,IAAIwC,MAAM,CAACC,QAAQ,CAAC7D,OAAO,CAACoB,OAAO,CAAC,CAAC,IACzE,CAACuC,gBAAgB,EAAE;MAEnBnB,GAAG,CAACc,OAAO,CAAC,gBAAgB,CAAC,GAAGM,MAAM,CAACC,QAAQ,CAAC7D,OAAO,CAACoB,OAAO,CAAC,GAAGpB,OAAO,CAACoB,OAAO,CAAC6C,MAAM,GAAGL,MAAM,CAACM,UAAU,CAAClE,OAAO,CAACoB,OAAO,CAAC;IAClI;IAEA,IAAI+C,SAAS,GAAGnE,OAAO,CAACoE,cAAc,CAAC,WAAW,CAAC,GAAGpE,OAAO,CAACmE,SAAS,GAAG,KAAK,CAAC,CAAQ;;IAExF5B,MAAM,GAAGA,MAAM,IAAI,EAAE;IACrBA,MAAM,CAAC8B,IAAI,CAAC;MAAEnD,MAAM,EAAEsB,GAAG,CAACtB,MAAM;MAAEC;IAAI,CAAC,CAAC;IAExC,MAAMmD,MAAM,GAAG9B,GAAG,CAACM,QAAQ,KAAK,QAAQ,GAAG7D,KAAK,GAAGD,IAAI;IAEvD,IAAIgB,OAAO,CAACY,kBAAkB,KAAKS,SAAS,IACxCmB,GAAG,CAACM,QAAQ,KAAK,QAAQ,EAAE;MAE3BN,GAAG,CAACjB,KAAK,GAAGvB,OAAO,CAACY,kBAAkB,GAAG,IAAI,CAACV,MAAM,CAACC,KAAK,GAAG,IAAI,CAACD,MAAM,CAACG,sBAAsB;IACnG,CAAC,MACI,IAAIL,OAAO,CAACuB,KAAK,IAClBvB,OAAO,CAACuB,KAAK,KAAK,KAAK,EAAE;MAEzBiB,GAAG,CAACjB,KAAK,GAAGvB,OAAO,CAACuB,KAAK;IAC7B,CAAC,MACI;MACDiB,GAAG,CAACjB,KAAK,GAAGiB,GAAG,CAACM,QAAQ,KAAK,QAAQ,GAAG,IAAI,CAAC5C,MAAM,CAACC,KAAK,GAAG,IAAI,CAACD,MAAM,CAACE,IAAI;IAChF;IAEA,IAAIJ,OAAO,CAACuE,cAAc,KAAKlD,SAAS,EAAE;MACtCmB,GAAG,CAAC+B,cAAc,GAAGvE,OAAO,CAACuE,cAAc;IAC/C;IAEA,IAAIvE,OAAO,CAACwE,OAAO,KAAKnD,SAAS,EAAE;MAC/BmB,GAAG,CAACgC,OAAO,GAAGxE,OAAO,CAACwE,OAAO;IACjC;IAEA,IAAI,CAACC,KAAK,CAAC,YAAY,EAAEjC,GAAG,EAAExC,OAAO,CAAC;IAEtC,MAAM0E,KAAK,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;IACxB,MAAM3C,GAAG,GAAGqC,MAAM,CAACrD,OAAO,CAACuB,GAAG,CAAC;IAE/B,IAAI,CAACiC,KAAK,CAAC,SAAS,EAAExC,GAAG,CAAC;IAE1B,IAAI4C,MAAM,GAAG,IAAI,CAAC,CAAsE;IACxF,IAAIC,SAAS;IAEb,MAAMC,OAAO,GAAIpD,GAAG,IAAK;MAErBA,GAAG,CAACqD,KAAK,GAAGzC,MAAM;MAClB,OAAO0C,UAAU,CAAC5F,IAAI,CAAC6F,UAAU,CAAC,sBAAsB,EAAEvD,GAAG,CAAC,CAAC;IACnE,CAAC;IAED,MAAMwD,OAAO,GAAGA,CAAA,KAAM;MAElB,IAAI,CAAClD,GAAG,CAACmD,MAAM,EAAE;QACb;;QAEA,MAAMC,KAAK,GAAG,IAAIC,KAAK,CAAC,gBAAgB,CAAC;QACzCD,KAAK,CAACE,IAAI,GAAG,YAAY;QACzBN,UAAU,CAACI,KAAK,CAAC;MACrB;IACJ,CAAC;IAEDpD,GAAG,CAACuD,IAAI,CAAC,OAAO,EAAET,OAAO,CAAC;IAE1B,MAAMU,UAAU,GAAInD,GAAG,IAAK;MAExB;;MAEA,MAAMoD,UAAU,GAAGpD,GAAG,CAACoD,UAAU;MACjC,MAAMC,cAAc,GAAGhG,SAAS,CAACgG,cAAc,CAACD,UAAU,EAAElD,GAAG,CAACtB,MAAM,EAAElB,OAAO,CAAC;MAEhF,IAAImE,SAAS,KAAK,KAAK,IACnB,CAACwB,cAAc,EAAE;QAEjB,OAAOV,UAAU,CAAC,IAAI,EAAE3C,GAAG,CAAC;MAChC;;MAEA;;MAEAA,GAAG,CAACsD,OAAO,CAAC,CAAC;MAEb,IAAIzB,SAAS,KAAK,CAAC,EAAE;QACjB,OAAOc,UAAU,CAAC5F,IAAI,CAAC6F,UAAU,CAAC,8BAA8B,EAAE3C,MAAM,CAAC,CAAC;MAC9E;MAEA,IAAIsD,QAAQ,GAAGvD,GAAG,CAACgB,OAAO,CAACuC,QAAQ;MACnC,IAAI,CAACA,QAAQ,EAAE;QACX,OAAOZ,UAAU,CAAC5F,IAAI,CAAC6F,UAAU,CAAC,uCAAuC,EAAE3C,MAAM,CAAC,CAAC;MACvF;MAEA,IAAI,CAAC,WAAW,CAACuD,IAAI,CAACD,QAAQ,CAAC,EAAE;QAC7BA,QAAQ,GAAG1G,GAAG,CAACiD,OAAO,CAACI,GAAG,CAACW,IAAI,EAAE0C,QAAQ,CAAC;MAC9C;MAEA,MAAME,eAAe,GAAGxG,IAAI,CAACgB,KAAK,CAACP,OAAO,EAAE;QAAEQ,OAAO,EAAEb,SAAS,CAACE;MAAe,CAAC,CAAC;MAClFkG,eAAe,CAAC3E,OAAO,GAAGyD,MAAM,IAAI7E,OAAO,CAACoB,OAAO,CAAC,CAAoC;MACxF2E,eAAe,CAAC5B,SAAS,GAAG,EAAEA,SAAS;MACvC,IAAIW,SAAS,EAAE;QACXkB,YAAY,CAAClB,SAAS,CAAC;QACvB,MAAMmB,OAAO,GAAGtB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,KAAK;QAClCqB,eAAe,CAACG,OAAO,GAAG,CAACH,eAAe,CAACG,OAAO,GAAGD,OAAO,EAAEE,QAAQ,CAAC,CAAC,CAAC,CAAW;MACxF;;MAEA;MACA,IAAIJ,eAAe,CAACzC,OAAO,EAAE;QACzB,MAAM8C,cAAc,GAAG,IAAIzD,GAAG,CAACkD,QAAQ,CAAC;QACxC,IAAIrD,GAAG,CAAC6D,QAAQ,KAAKD,cAAc,CAACC,QAAQ,EAAE;UAC1C,KAAK,MAAMC,MAAM,IAAI/C,MAAM,CAACgD,IAAI,CAACR,eAAe,CAACzC,OAAO,CAAC,EAAE;YACvD,MAAMkD,WAAW,GAAGF,MAAM,CAACG,WAAW,CAAC,CAAC;YACxC,IAAID,WAAW,KAAK,eAAe,IAAIA,WAAW,KAAK,QAAQ,EAAE;cAC7D,OAAOT,eAAe,CAACzC,OAAO,CAACgD,MAAM,CAAC;YAC1C;UACJ;QACJ;MACJ;MAEA,MAAMI,cAAc,GAAI/E,GAAG,IAAK;QAE5B,IAAIA,GAAG,EAAE;UACLA,GAAG,CAACqD,KAAK,GAAGzC,MAAM;UAClB,OAAO0C,UAAU,CAAC5F,IAAI,CAAC6F,UAAU,CAAC,kBAAkB,EAAEvD,GAAG,CAAC,CAAC;QAC/D;QAEA,MAAMgF,WAAW,GAAG,IAAI,CAACzE,QAAQ,CAACyD,cAAc,EAAEE,QAAQ,EAAEE,eAAe,EAAE;UAAE1D,QAAQ,EAAE4C;QAAW,CAAC,EAAE1C,MAAM,CAAC;QAC9G,IAAIvC,OAAO,CAACyB,UAAU,EAAE;UACpBzB,OAAO,CAACyB,UAAU,CAACiE,UAAU,EAAEG,QAAQ,EAAEc,WAAW,CAAC;QACzD;MACJ,CAAC;MAED,IAAI,CAAC3G,OAAO,CAACwB,cAAc,EAAE;QACzB,OAAOkF,cAAc,CAAC,CAAC;MAC3B;MAEA,OAAO1G,OAAO,CAACwB,cAAc,CAACmE,cAAc,EAAED,UAAU,EAAEG,QAAQ,EAAEvD,GAAG,CAACgB,OAAO,EAAEyC,eAAe,EAAEW,cAAc,CAAC;IACrH,CAAC;;IAED;;IAEA,MAAME,MAAM,GAAGA,CAACjF,GAAG,EAAEW,GAAG,KAAK;MAEzB,IAAIX,GAAG,EAAE;QACLM,GAAG,CAAC4E,KAAK,CAAC,CAAC;MACf;MAEA5E,GAAG,CAAC6E,cAAc,CAAC,UAAU,EAAErB,UAAU,CAAC;MAC1CxD,GAAG,CAAC6E,cAAc,CAAC,OAAO,EAAE/B,OAAO,CAAC;MACpC9C,GAAG,CAAC6E,cAAc,CAAC,OAAO,EAAE3B,OAAO,CAAC;MACpClD,GAAG,CAAC8E,EAAE,CAAC,OAAO,EAAExH,IAAI,CAACyH,MAAM,CAAC;MAE5BhB,YAAY,CAAClB,SAAS,CAAC;MAEvB,IAAI,CAACL,KAAK,CAAC,UAAU,EAAE9C,GAAG,EAAE;QAAEM,GAAG;QAAEK,GAAG;QAAEoC,KAAK;QAAElC;MAAI,CAAC,CAAC;MAErD,OAAOR,KAAK,CAACK,QAAQ,CAACV,GAAG,EAAEW,GAAG,CAAC;IACnC,CAAC;IAED,MAAM2C,UAAU,GAAG1F,IAAI,CAACiG,IAAI,CAACoB,MAAM,CAAC;IAEpC3E,GAAG,CAACuD,IAAI,CAAC,UAAU,EAAEC,UAAU,CAAC;IAEhC,IAAIzF,OAAO,CAACkG,OAAO,EAAE;MACjBpB,SAAS,GAAGmC,UAAU,CAAC,MAAMhC,UAAU,CAAC5F,IAAI,CAAC6H,cAAc,CAAC,wBAAwB,CAAC,CAAC,EAAElH,OAAO,CAACkG,OAAO,CAAC;IAC5G;IAEAjE,GAAG,CAAC8E,EAAE,CAAC,OAAO,EAAE5B,OAAO,CAAC;;IAExB;;IAEA,IAAInB,gBAAgB,EAAE;MAClB,IAAIhE,OAAO,CAACoB,OAAO,YAAYlC,MAAM,EAAE;QACnC,IAAIiI,MAAM,GAAGnH,OAAO,CAACoB,OAAO;QAE5B,IAAI+C,SAAS,EAAE;UACX,MAAMiD,SAAS,GAAG,IAAI1H,GAAG,CAAC,CAAC;UAC3B0H,SAAS,CAAC5B,IAAI,CAAC,QAAQ,EAAE,MAAM;YAE3BX,MAAM,GAAGuC,SAAS,CAACC,OAAO,CAAC,CAAC;UAChC,CAAC,CAAC;UAEFF,MAAM,GAAGnH,OAAO,CAACoB,OAAO,CAACkG,IAAI,CAACF,SAAS,CAAC;QAC5C;QAEAzH,SAAS,CAAC4H,4BAA4B,CAACtF,GAAG,EAAEkF,MAAM,CAAC;QACnD,OAAOlF,GAAG;MACd;MAEAA,GAAG,CAACuF,KAAK,CAACxH,OAAO,CAACoB,OAAO,CAAC;IAC9B;;IAEA;;IAEAa,GAAG,CAACwF,GAAG,CAAC,CAAC;IACT,OAAOxF,GAAG;EACd;EAEAwC,KAAKA,CAAC,GAAGiD,IAAI,EAAE;IAEX,IAAI,IAAI,CAAC7G,MAAM,EAAE;MACb,IAAI,CAACA,MAAM,CAAC8G,IAAI,CAAC,GAAGD,IAAI,CAAC;IAC7B;EACJ;EAEAE,IAAIA,CAACtF,GAAG,EAAEtC,OAAO,GAAG,CAAC,CAAC,EAAE;IAEpB,OAAO,IAAI4B,OAAO,CAAC,CAACQ,OAAO,EAAEP,MAAM,KAAK;MAEpC,IAAI,CAACgG,KAAK,CAACvF,GAAG,EAAEtC,OAAO,EAAE,CAAC2B,GAAG,EAAEP,OAAO,KAAK;QAEvC,IAAIO,GAAG,EAAE;UACLE,MAAM,CAACF,GAAG,CAAC;UACX;QACJ;QAEAS,OAAO,CAAChB,OAAO,CAAC;QAChB;MACJ,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EAEAyG,KAAKA,CAACvF,GAAG,EAAEtC,OAAO,EAAEqC,QAAQ,EAAE;IAE1BrC,OAAO,GAAGT,IAAI,CAACyB,eAAe,CAAC,IAAI,CAACV,SAAS,EAAEN,OAAO,EAAE;MAAEQ,OAAO,EAAEb,SAAS,CAACE;IAAe,CAAC,CAAC;;IAE9F;;IAEA,IAAIiI,eAAe,GAAG,IAAI;IAE1B,MAAMlB,MAAM,GAAGA,CAACjF,GAAG,EAAEoG,MAAM,KAAK;MAE5B/B,YAAY,CAAC8B,eAAe,CAAC;MAC7BE,MAAM,CAAClB,cAAc,CAAC,OAAO,EAAEmB,aAAa,CAAC;MAC7CD,MAAM,CAAClB,cAAc,CAAC,QAAQ,EAAEoB,cAAc,CAAC;MAC/C5F,GAAG,CAACwE,cAAc,CAAC,OAAO,EAAEqB,UAAU,CAAC;MACvC7F,GAAG,CAACwE,cAAc,CAAC,OAAO,EAAEsB,YAAY,CAAC;MACzC9F,GAAG,CAACwE,cAAc,CAAC,SAAS,EAAEsB,YAAY,CAAC;MAC3C9F,GAAG,CAACyE,EAAE,CAAC,OAAO,EAAExH,IAAI,CAACyH,MAAM,CAAC;MAE5B,IAAIrF,GAAG,EAAE;QACL,OAAOU,QAAQ,CAACV,GAAG,CAAC;MACxB;MAEA,IAAI,CAAC3B,OAAO,CAACqI,IAAI,EAAE;QACf,OAAOhG,QAAQ,CAAC,IAAI,EAAE0F,MAAM,CAAC;MACjC;;MAEA;;MAEA,IAAI/H,OAAO,CAACqI,IAAI,KAAK,OAAO,EAAE;QAC1B,OAAO1I,SAAS,CAAC2I,cAAc,CAACP,MAAM,EAAE1F,QAAQ,CAAC;MACrD;;MAEA;;MAEA,MAAMkG,WAAW,GAAGjG,GAAG,CAACgB,OAAO,IAAI3D,SAAS,CAAC+D,UAAU,CAAC,cAAc,EAAEpB,GAAG,CAACgB,OAAO,CAAC,IAAI,EAAE;MAC1F,MAAMkF,IAAI,GAAGD,WAAW,CAACE,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAACC,IAAI,CAAC,CAAC,CAACjC,WAAW,CAAC,CAAC;MAE3D,IAAI,CAAC9G,SAAS,CAACC,SAAS,CAACkG,IAAI,CAAC0C,IAAI,CAAC,EAAE;QACjC,IAAIxI,OAAO,CAACqI,IAAI,KAAK,QAAQ,EAAE;UAC3B,OAAOhG,QAAQ,CAAChD,IAAI,CAACsJ,aAAa,CAAC,yCAAyC,CAAC,CAAC;QAClF;QAEA,OAAOtG,QAAQ,CAAC,IAAI,EAAE0F,MAAM,CAAC;MACjC;MAEA,OAAOpI,SAAS,CAAC2I,cAAc,CAACP,MAAM,EAAE1F,QAAQ,CAAC;IACrD,CAAC;IAED,MAAM4C,UAAU,GAAG1F,IAAI,CAACiG,IAAI,CAACoB,MAAM,CAAC;IAEpC,MAAMgC,aAAa,GAAG5I,OAAO,CAACkG,OAAO;IACrC,IAAI0C,aAAa,IACbA,aAAa,GAAG,CAAC,EAAE;MAEnBd,eAAe,GAAGb,UAAU,CAAC,MAAMhC,UAAU,CAAC5F,IAAI,CAACuJ,aAAa,CAAC,CAAC,CAAC,EAAEA,aAAa,CAAC;IACvF;;IAEA;;IAEA,MAAMT,UAAU,GAAIxG,GAAG,IAAK;MAExB,OAAOsD,UAAU,CAACtD,GAAG,CAACkH,MAAM,GAAGlH,GAAG,GAAGtC,IAAI,CAACyJ,QAAQ,CAAC,sBAAsB,EAAEnH,GAAG,CAAC,CAAC;IACpF,CAAC;IAED,MAAMyG,YAAY,GAAGA,CAAA,KAAM;MAEvB,IAAI,CAAC9F,GAAG,CAACyG,QAAQ,EAAE;QACf9D,UAAU,CAAC5F,IAAI,CAACyJ,QAAQ,CAAC,mCAAmC,CAAC,CAAC;MAClE;IACJ,CAAC;IAEDxG,GAAG,CAACkD,IAAI,CAAC,OAAO,EAAE2C,UAAU,CAAC;IAC7B7F,GAAG,CAACkD,IAAI,CAAC,OAAO,EAAE4C,YAAY,CAAC;IAC/B9F,GAAG,CAACkD,IAAI,CAAC,SAAS,EAAE4C,YAAY,CAAC;;IAEjC;;IAEA,MAAMJ,MAAM,GAAG,IAAIvI,QAAQ,CAAC;MAAEuJ,QAAQ,EAAEhJ,OAAO,CAACgJ;IAAS,CAAC,CAAC;IAE3D,MAAMf,aAAa,GAAItG,GAAG,IAAK;MAE3B,IAAIW,GAAG,CAACsD,OAAO,EAAE;QAA2B;QACxCtD,GAAG,CAACsD,OAAO,CAAC,CAAC;MACjB;MAEA,OAAOX,UAAU,CAACtD,GAAG,CAAC;IAC1B,CAAC;IAEDqG,MAAM,CAACxC,IAAI,CAAC,OAAO,EAAEyC,aAAa,CAAC;IAEnC,MAAMC,cAAc,GAAGA,CAAA,KAAM;MAEzB,OAAOjD,UAAU,CAAC,IAAI,EAAE+C,MAAM,CAACX,OAAO,CAAC,CAAC,CAAC;IAC7C,CAAC;IAEDW,MAAM,CAACxC,IAAI,CAAC,QAAQ,EAAE0C,cAAc,CAAC;IAErC,IAAIlI,OAAO,CAAC0B,MAAM,EAAE;MAChB,MAAMuH,eAAe,GAAGjJ,OAAO,CAAC0B,MAAM,KAAK,OAAO,GAC9C,MAAM,GACNY,GAAG,CAACgB,OAAO,IAAI3D,SAAS,CAAC+D,UAAU,CAAC,kBAAkB,EAAEpB,GAAG,CAACgB,OAAO,CAAC,IAAI,EAAE;MAE9E,IAAI,+BAA+B,CAACwC,IAAI,CAACmD,eAAe,CAAC,EAAE;QACvD,MAAMvH,MAAM,GAAGtC,IAAI,CAAC8J,YAAY,CAAC,CAAC;QAClCxH,MAAM,CAAC8D,IAAI,CAAC,OAAO,EAAEyC,aAAa,CAAC;QACnC3F,GAAG,CAACgF,IAAI,CAAC5F,MAAM,CAAC,CAAC4F,IAAI,CAACU,MAAM,CAAC;QAC7B;MACJ;IACJ;IAEA1F,GAAG,CAACgF,IAAI,CAACU,MAAM,CAAC;EACpB;EAEAmB,gBAAgBA,CAAC/H,OAAO,EAAEgI,QAAQ,EAAE;IAEhC,OAAO,IAAI5J,OAAO,CAAC4B,OAAO,EAAEgI,QAAQ,CAAC;EACzC;EAEAC,iBAAiBA,CAACC,KAAK,EAAE;IAErB;AACR;AACA;AACA;AACA;AACA;;IAEQ;IACA,MAAMC,KAAK,GAAG,0JAA0J;IAExK,MAAMjD,MAAM,GAAG,CAAC,CAAC;IACjB,MAAMjB,KAAK,GAAGiE,KAAK,CAACE,OAAO,CAACD,KAAK,EAAE,CAACE,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,KAAK;MAEnD,MAAMC,KAAK,GAAGF,EAAE,IAAIC,EAAE;MACtBtD,MAAM,CAACoD,EAAE,CAAC,GAAGG,KAAK,GAAGA,KAAK,CAACpD,WAAW,CAAC,CAAC,GAAG,IAAI;MAC/C,OAAO,EAAE;IACb,CAAC,CAAC;IAEF,IAAIH,MAAM,CAAC,SAAS,CAAC,EAAE;MACnB,IAAI;QACA,MAAMwD,MAAM,GAAGC,QAAQ,CAACzD,MAAM,CAAC,SAAS,CAAC,EAAE,EAAE,CAAC;QAC9C,IAAI0D,KAAK,CAACF,MAAM,CAAC,EAAE;UACf,OAAO,IAAI;QACf;QAEAxD,MAAM,CAAC,SAAS,CAAC,GAAGwD,MAAM;MAC9B,CAAC,CACD,OAAOnI,GAAG,EAAE,CAAE;IAClB;IAEA,OAAO0D,KAAK,GAAG,IAAI,GAAGiB,MAAM;EAChC;;EAEA;;EAEA2D,GAAGA,CAACzH,GAAG,EAAExC,OAAO,EAAE;IAEd,OAAO,IAAI,CAACkK,SAAS,CAAC,KAAK,EAAE1H,GAAG,EAAExC,OAAO,CAAC;EAC9C;EAEAmK,IAAIA,CAAC3H,GAAG,EAAExC,OAAO,EAAE;IAEf,OAAO,IAAI,CAACkK,SAAS,CAAC,MAAM,EAAE1H,GAAG,EAAExC,OAAO,CAAC;EAC/C;EAEAoK,KAAKA,CAAC5H,GAAG,EAAExC,OAAO,EAAE;IAEhB,OAAO,IAAI,CAACkK,SAAS,CAAC,OAAO,EAAE1H,GAAG,EAAExC,OAAO,CAAC;EAChD;EAEAqK,GAAGA,CAAC7H,GAAG,EAAExC,OAAO,EAAE;IAEd,OAAO,IAAI,CAACkK,SAAS,CAAC,KAAK,EAAE1H,GAAG,EAAExC,OAAO,CAAC;EAC9C;EAEAsK,MAAMA,CAAC9H,GAAG,EAAExC,OAAO,EAAE;IAEjB,OAAO,IAAI,CAACkK,SAAS,CAAC,QAAQ,EAAE1H,GAAG,EAAExC,OAAO,CAAC;EACjD;EAEA,MAAMkK,SAASA,CAAChJ,MAAM,EAAEsB,GAAG,EAAExC,OAAO,GAAG,CAAC,CAAC,EAAE;IAEvC,MAAMsC,GAAG,GAAG,MAAM,IAAI,CAACrB,OAAO,CAACC,MAAM,EAAEsB,GAAG,EAAExC,OAAO,CAAC;IAEpD,IAAIoB,OAAO;IACX,IAAI;MACAA,OAAO,GAAG,MAAM,IAAI,CAACwG,IAAI,CAACtF,GAAG,EAAEtC,OAAO,CAAC;IAC3C,CAAC,CACD,OAAO2B,GAAG,EAAE;MACRA,GAAG,CAAC4I,IAAI,GAAG5I,GAAG,CAAC4I,IAAI,IAAI,CAAC,CAAC;MACzB5I,GAAG,CAAC4I,IAAI,CAACjI,GAAG,GAAGA,GAAG;MAClB,MAAMX,GAAG;IACb;IAEA,IAAIW,GAAG,CAACoD,UAAU,GAAG,GAAG,EAAE;MACtB,OAAO;QAAEpD,GAAG;QAAElB;MAAQ,CAAC;IAC3B;;IAEA;;IAEA,MAAMmJ,IAAI,GAAG;MACTC,eAAe,EAAE,IAAI;MACrBlH,OAAO,EAAEhB,GAAG,CAACgB,OAAO;MACpBhB,GAAG;MACHlB;IACJ,CAAC;IAED,MAAM,IAAI/B,IAAI,CAACA,IAAI,CAAE,mBAAkBiD,GAAG,CAACoD,UAAW,IAAGpD,GAAG,CAACmI,aAAc,EAAC,EAAE;MAAE/E,UAAU,EAAEpD,GAAG,CAACoD,UAAU;MAAE6E;IAAK,CAAC,CAAC;EACvH;AACJ,CAAC;;AAGD;;AAEA5K,SAAS,CAACoC,UAAU,GAAG,UAAUD,OAAO,EAAE4I,IAAI,EAAE;EAE5C,IAAI,CAACA,IAAI,EAAE;IACP,OAAO5I,OAAO;EAClB;;EAEA;EACA,MAAMX,GAAG,GAAG,IAAIhC,GAAG,CAACwD,GAAG,CAAC+H,IAAI,EAAE5I,OAAO,CAAC;EACtC,OAAO3C,GAAG,CAACwL,MAAM,CAACxJ,GAAG,CAAC;AAC1B,CAAC;AAGDxB,SAAS,CAAC4H,4BAA4B,GAAG,UAAUtF,GAAG,EAAEkF,MAAM,EAAE;EAE5D,MAAMyD,QAAQ,GAAIxF,MAAM,IAAK;IAEzB,IAAI,CAACA,MAAM,CAACyF,UAAU,EAAE;MACpB,OAAOC,eAAe,CAAC,CAAC;IAC5B;IAEA1F,MAAM,CAACI,IAAI,CAAC,SAAS,EAAEsF,eAAe,CAAC;EAC3C,CAAC;EAED,MAAMA,eAAe,GAAGA,CAAA,KAAM;IAE1B3D,MAAM,CAACG,IAAI,CAACrF,GAAG,CAAC;IAChBkF,MAAM,CAACL,cAAc,CAAC,OAAO,EAAEiE,aAAa,CAAC;EACjD,CAAC;EAED,MAAMA,aAAa,GAAIpJ,GAAG,IAAK;IAE3BM,GAAG,CAAC0F,IAAI,CAAC,OAAO,EAAEhG,GAAG,CAAC;EAC1B,CAAC;EAEDM,GAAG,CAACuD,IAAI,CAAC,QAAQ,EAAEoF,QAAQ,CAAC;EAC5BzD,MAAM,CAACJ,EAAE,CAAC,OAAO,EAAEgE,aAAa,CAAC;AACrC,CAAC;AAGDpL,SAAS,CAACgG,cAAc,GAAG,UAAUJ,IAAI,EAAErE,MAAM,EAAElB,OAAO,EAAE;EAExD,QAAQuF,IAAI;IACR,KAAK,GAAG;IACR,KAAK,GAAG;MACJ,OAAOvF,OAAO,CAAC2F,cAAc,IAAIzE,MAAM;IAE3C,KAAK,GAAG;MACJ,IAAIlB,OAAO,CAACgL,WAAW,EAAE;QACrB,OAAO,KAAK;MAChB;MAEA;IAEJ,KAAK,GAAG;IACR,KAAK,GAAG;MACJ,OAAO9J,MAAM;EACrB;EAEA,OAAO,IAAI;AACf,CAAC;AAGDvB,SAAS,CAAC2I,cAAc,GAAG,UAAUP,MAAM,EAAEkD,IAAI,EAAE;EAE/C,IAAIlD,MAAM,CAAC9D,MAAM,KAAK,CAAC,EAAE;IACrB,OAAOgH,IAAI,CAAC,IAAI,EAAE,IAAI,CAAC;EAC3B;EAEA,IAAI7J,OAAO;EACX,IAAI;IACAA,OAAO,GAAG9B,MAAM,CAAC4L,KAAK,CAACnD,MAAM,CAAC5B,QAAQ,CAAC,CAAC,CAAC;EAC7C,CAAC,CACD,OAAOxE,GAAG,EAAE;IACR,OAAOsJ,IAAI,CAAC5L,IAAI,CAAC6F,UAAU,CAACvD,GAAG,CAACwJ,OAAO,EAAE;MAAE/J,OAAO,EAAE2G;IAAO,CAAC,CAAC,CAAC;EAClE;EAEA,OAAOkD,IAAI,CAAC,IAAI,EAAE7J,OAAO,CAAC;AAC9B,CAAC;AAGDzB,SAAS,CAAC+D,UAAU,GAAG,UAAU0H,UAAU,EAAE9H,OAAO,EAAE;EAElD,MAAM+H,cAAc,GAAGD,UAAU,CAAC3E,WAAW,CAAC,CAAC;EAE/C,KAAK,MAAM6E,GAAG,IAAI/H,MAAM,CAACgD,IAAI,CAACjD,OAAO,CAAC,EAAE;IACpC,IAAIgI,GAAG,CAAC7E,WAAW,CAAC,CAAC,KAAK4E,cAAc,EAAE;MACtC,OAAO/H,OAAO,CAACgI,GAAG,CAAC;IACvB;EACJ;AACJ,CAAC;AAGD3L,SAAS,CAACiD,iBAAiB,GAAG,CAAC5C,OAAO,EAAEmB,GAAG,KAAK;EAE5CnB,OAAO,CAAC6C,IAAI,GAAG1B,GAAG,CAAC0B,IAAI;EACvB7C,OAAO,CAACuL,MAAM,GAAGpK,GAAG,CAACoK,MAAM;EAC3BvL,OAAO,CAACiD,YAAY,GAAG9B,GAAG,CAAC8B,YAAY;EACvCjD,OAAO,CAAC8C,QAAQ,GAAG3B,GAAG,CAAC2B,QAAQ;EAC/B9C,OAAO,CAACqG,QAAQ,GAAG,OAAOlF,GAAG,CAACkF,QAAQ,KAAK,QAAQ,IAAIlF,GAAG,CAACkF,QAAQ,CAACmF,UAAU,CAAC,GAAG,CAAC,GAAGrK,GAAG,CAACkF,QAAQ,CAACoF,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAGtK,GAAG,CAACkF,QAAQ;EAC9HrG,OAAO,CAAC+C,IAAI,GAAG5B,GAAG,CAAC4B,IAAI;EACvB/C,OAAO,CAACgD,MAAM,GAAG7B,GAAG,CAAC6B,MAAM;EAC3BhD,OAAO,CAACkD,QAAQ,GAAG/B,GAAG,CAAC+B,QAAQ;EAC/BlD,OAAO,CAAC0K,IAAI,GAAI,GAAEvJ,GAAG,CAAC+B,QAAS,GAAE/B,GAAG,CAAC6B,MAAO,EAAC;EAC7ChD,OAAO,CAACmD,IAAI,GAAGhC,GAAG,CAACgC,IAAI;EACvB,IAAIhC,GAAG,CAACuK,IAAI,KAAK,EAAE,EAAE;IACjB1L,OAAO,CAAC0L,IAAI,GAAGC,MAAM,CAACxK,GAAG,CAACuK,IAAI,CAAC;EACnC;EAEA,IAAIvK,GAAG,CAACyK,QAAQ,IAAIzK,GAAG,CAAC0K,QAAQ,EAAE;IAC9B7L,OAAO,CAAC8L,IAAI,GAAI,GAAE3K,GAAG,CAACyK,QAAS,IAAGzK,GAAG,CAAC0K,QAAS,EAAC;IAChD7L,OAAO,CAAC4L,QAAQ,GAAGzK,GAAG,CAACyK,QAAQ;IAC/B5L,OAAO,CAAC6L,QAAQ,GAAG1K,GAAG,CAAC0K,QAAQ;EACnC;EAEA,OAAO7L,OAAO;AAClB,CAAC;AAEDL,SAAS,CAAC2B,iBAAiB,GAAIyK,GAAG,IAAK,CAAC,IAAI,EAAE1K,SAAS,CAAC,CAAC2K,QAAQ,CAACD,GAAG,CAAC;AAEtEE,MAAM,CAACC,OAAO,GAAG,IAAIvM,SAAS,CAACG,MAAM,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}