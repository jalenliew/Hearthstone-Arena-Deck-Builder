{"ast":null,"code":"'use strict';\n\nconst Reach = require('./reach');\nconst Types = require('./types');\nconst Utils = require('./utils');\nconst internals = {\n  needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n  let clone = internals.clone;\n  let seen = _seen;\n  if (options.shallow) {\n    if (options.shallow !== true) {\n      return internals.cloneWithShallow(obj, options);\n    }\n    clone = value => value;\n  } else if (seen) {\n    const lookup = seen.get(obj);\n    if (lookup) {\n      return lookup;\n    }\n  } else {\n    seen = new Map();\n  }\n\n  // Built-in object types\n\n  const baseProto = Types.getInternalProto(obj);\n  if (baseProto === Types.buffer) {\n    return Buffer && Buffer.from(obj); // $lab:coverage:ignore$\n  }\n\n  if (baseProto === Types.date) {\n    return new Date(obj.getTime());\n  }\n  if (baseProto === Types.regex) {\n    return new RegExp(obj);\n  }\n\n  // Generic objects\n\n  const newObj = internals.base(obj, baseProto, options);\n  if (newObj === obj) {\n    return obj;\n  }\n  if (seen) {\n    seen.set(obj, newObj); // Set seen, since obj could recurse\n  }\n\n  if (baseProto === Types.set) {\n    for (const value of obj) {\n      newObj.add(clone(value, options, seen));\n    }\n  } else if (baseProto === Types.map) {\n    for (const [key, value] of obj) {\n      newObj.set(key, clone(value, options, seen));\n    }\n  }\n  const keys = Utils.keys(obj, options);\n  for (const key of keys) {\n    if (key === '__proto__') {\n      continue;\n    }\n    if (baseProto === Types.array && key === 'length') {\n      newObj.length = obj.length;\n      continue;\n    }\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n    if (descriptor) {\n      if (descriptor.get || descriptor.set) {\n        Object.defineProperty(newObj, key, descriptor);\n      } else if (descriptor.enumerable) {\n        newObj[key] = clone(obj[key], options, seen);\n      } else {\n        Object.defineProperty(newObj, key, {\n          enumerable: false,\n          writable: true,\n          configurable: true,\n          value: clone(obj[key], options, seen)\n        });\n      }\n    } else {\n      Object.defineProperty(newObj, key, {\n        enumerable: true,\n        writable: true,\n        configurable: true,\n        value: clone(obj[key], options, seen)\n      });\n    }\n  }\n  return newObj;\n};\ninternals.cloneWithShallow = function (source, options) {\n  const keys = options.shallow;\n  options = Object.assign({}, options);\n  options.shallow = false;\n  const seen = new Map();\n  for (const key of keys) {\n    const ref = Reach(source, key);\n    if (typeof ref === 'object' || typeof ref === 'function') {\n      seen.set(ref, ref);\n    }\n  }\n  return internals.clone(source, options, seen);\n};\ninternals.base = function (obj, baseProto, options) {\n  if (options.prototype === false) {\n    // Defaults to true\n    if (internals.needsProtoHack.has(baseProto)) {\n      return new baseProto.constructor();\n    }\n    return baseProto === Types.array ? [] : {};\n  }\n  const proto = Object.getPrototypeOf(obj);\n  if (proto && proto.isImmutable) {\n    return obj;\n  }\n  if (baseProto === Types.array) {\n    const newObj = [];\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n    return newObj;\n  }\n  if (internals.needsProtoHack.has(baseProto)) {\n    const newObj = new proto.constructor();\n    if (proto !== baseProto) {\n      Object.setPrototypeOf(newObj, proto);\n    }\n    return newObj;\n  }\n  return Object.create(proto);\n};","map":{"version":3,"names":["Reach","require","Types","Utils","internals","needsProtoHack","Set","set","map","weakSet","weakMap","module","exports","clone","obj","options","_seen","seen","shallow","cloneWithShallow","value","lookup","get","Map","baseProto","getInternalProto","buffer","Buffer","from","date","Date","getTime","regex","RegExp","newObj","base","add","key","keys","array","length","descriptor","Object","getOwnPropertyDescriptor","defineProperty","enumerable","writable","configurable","source","assign","ref","prototype","has","constructor","proto","getPrototypeOf","isImmutable","setPrototypeOf","create"],"sources":["C:/Programming/Hearthstone/Hearthstone-Arena-Deck-Builder/hearthstone-app/node_modules/@hapi/boom/node_modules/@hapi/hoek/lib/clone.js"],"sourcesContent":["'use strict';\n\nconst Reach = require('./reach');\nconst Types = require('./types');\nconst Utils = require('./utils');\n\n\nconst internals = {\n    needsProtoHack: new Set([Types.set, Types.map, Types.weakSet, Types.weakMap])\n};\n\n\nmodule.exports = internals.clone = function (obj, options = {}, _seen = null) {\n\n    if (typeof obj !== 'object' ||\n        obj === null) {\n\n        return obj;\n    }\n\n    let clone = internals.clone;\n    let seen = _seen;\n\n    if (options.shallow) {\n        if (options.shallow !== true) {\n            return internals.cloneWithShallow(obj, options);\n        }\n\n        clone = (value) => value;\n    }\n    else if (seen) {\n        const lookup = seen.get(obj);\n        if (lookup) {\n            return lookup;\n        }\n    }\n    else {\n        seen = new Map();\n    }\n\n    // Built-in object types\n\n    const baseProto = Types.getInternalProto(obj);\n    if (baseProto === Types.buffer) {\n        return Buffer && Buffer.from(obj);              // $lab:coverage:ignore$\n    }\n\n    if (baseProto === Types.date) {\n        return new Date(obj.getTime());\n    }\n\n    if (baseProto === Types.regex) {\n        return new RegExp(obj);\n    }\n\n    // Generic objects\n\n    const newObj = internals.base(obj, baseProto, options);\n    if (newObj === obj) {\n        return obj;\n    }\n\n    if (seen) {\n        seen.set(obj, newObj);                              // Set seen, since obj could recurse\n    }\n\n    if (baseProto === Types.set) {\n        for (const value of obj) {\n            newObj.add(clone(value, options, seen));\n        }\n    }\n    else if (baseProto === Types.map) {\n        for (const [key, value] of obj) {\n            newObj.set(key, clone(value, options, seen));\n        }\n    }\n\n    const keys = Utils.keys(obj, options);\n    for (const key of keys) {\n        if (key === '__proto__') {\n            continue;\n        }\n\n        if (baseProto === Types.array &&\n            key === 'length') {\n\n            newObj.length = obj.length;\n            continue;\n        }\n\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor) {\n            if (descriptor.get ||\n                descriptor.set) {\n\n                Object.defineProperty(newObj, key, descriptor);\n            }\n            else if (descriptor.enumerable) {\n                newObj[key] = clone(obj[key], options, seen);\n            }\n            else {\n                Object.defineProperty(newObj, key, { enumerable: false, writable: true, configurable: true, value: clone(obj[key], options, seen) });\n            }\n        }\n        else {\n            Object.defineProperty(newObj, key, {\n                enumerable: true,\n                writable: true,\n                configurable: true,\n                value: clone(obj[key], options, seen)\n            });\n        }\n    }\n\n    return newObj;\n};\n\n\ninternals.cloneWithShallow = function (source, options) {\n\n    const keys = options.shallow;\n    options = Object.assign({}, options);\n    options.shallow = false;\n\n    const seen = new Map();\n\n    for (const key of keys) {\n        const ref = Reach(source, key);\n        if (typeof ref === 'object' ||\n            typeof ref === 'function') {\n\n            seen.set(ref, ref);\n        }\n    }\n\n    return internals.clone(source, options, seen);\n};\n\n\ninternals.base = function (obj, baseProto, options) {\n\n    if (options.prototype === false) {                  // Defaults to true\n        if (internals.needsProtoHack.has(baseProto)) {\n            return new baseProto.constructor();\n        }\n\n        return baseProto === Types.array ? [] : {};\n    }\n\n    const proto = Object.getPrototypeOf(obj);\n    if (proto &&\n        proto.isImmutable) {\n\n        return obj;\n    }\n\n    if (baseProto === Types.array) {\n        const newObj = [];\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    if (internals.needsProtoHack.has(baseProto)) {\n        const newObj = new proto.constructor();\n        if (proto !== baseProto) {\n            Object.setPrototypeOf(newObj, proto);\n        }\n\n        return newObj;\n    }\n\n    return Object.create(proto);\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}