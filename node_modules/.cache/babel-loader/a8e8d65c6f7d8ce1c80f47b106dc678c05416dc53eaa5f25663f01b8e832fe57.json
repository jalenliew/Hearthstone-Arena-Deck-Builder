{"ast":null,"code":"'use strict';\n\nconst HEADER_ENCODING_FORMAT = 'base64';\nconst credentialsEncodingModeEnum = {\n  STRICT: 'strict',\n  LOOSE: 'loose'\n};\n\n/**\n * Encode a single {value} using the application/x-www-form-urlencoded media type\n * while also applying some additional rules specified by the spec\n *\n * Following characters are not-escaped by encodeURIComponent but {@link https://tools.ietf.org/html/rfc3986 RFC 3986}\n * lists them as 'reserved' and hence needs to be percent encoded, though they have no formalized URI delimiting cases\n *\n * >   ! ' ( ) *\n *\n * Percent encoding needs to be uppercase hexadecimal as per {@link https://tools.ietf.org/html/rfc3986#section-2.1 RFC 3986 - Percent Encoding}\n *\n * @see https://tools.ietf.org/html/rfc6749#appendix-B\n * @see https://tools.ietf.org/html/rfc6749#section-2.3.1\n *\n * @param {String} value\n */\nfunction useFormURLEncode(value) {\n  return encodeURIComponent(value).replace(/%20/g, '+').replace(/[!'()*]/g, c => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);\n}\n\n/**\n * Get a string representation for the client credentials\n *\n * @param {String} clientID\n * @param {String} clientSecret\n * @returns {String} credentials\n */\nfunction getCredentialsString(clientID, clientSecret) {\n  return `${clientID}:${clientSecret}`;\n}\nclass CredentialsEncoding {\n  constructor(encodingMode) {\n    this.encodingMode = encodingMode;\n  }\n\n  /**\n   * Get the authorization header used to request a valid token\n   * @param  {String} clientID\n   * @param  {String} clientSecret\n   * @return {String}              Authorization header string token\n   */\n  getAuthorizationHeaderToken(clientID, clientSecret) {\n    let encodedCredentials;\n    if (this.encodingMode === credentialsEncodingModeEnum.STRICT) {\n      encodedCredentials = getCredentialsString(useFormURLEncode(clientID), useFormURLEncode(clientSecret));\n    } else {\n      encodedCredentials = getCredentialsString(clientID, clientSecret);\n    }\n    return Buffer.from(encodedCredentials).toString(HEADER_ENCODING_FORMAT);\n  }\n}\nmodule.exports = {\n  CredentialsEncoding,\n  credentialsEncodingModeEnum\n};","map":{"version":3,"names":["HEADER_ENCODING_FORMAT","credentialsEncodingModeEnum","STRICT","LOOSE","useFormURLEncode","value","encodeURIComponent","replace","c","charCodeAt","toString","toUpperCase","getCredentialsString","clientID","clientSecret","CredentialsEncoding","constructor","encodingMode","getAuthorizationHeaderToken","encodedCredentials","Buffer","from","module","exports"],"sources":["C:/Programming/Hearthstone/Hearthstone-Arena-Deck-Builder/hearthstone-app/node_modules/simple-oauth2/lib/client/credentials-encoding.js"],"sourcesContent":["'use strict';\n\nconst HEADER_ENCODING_FORMAT = 'base64';\n\nconst credentialsEncodingModeEnum = {\n  STRICT: 'strict',\n  LOOSE: 'loose',\n};\n\n/**\n * Encode a single {value} using the application/x-www-form-urlencoded media type\n * while also applying some additional rules specified by the spec\n *\n * Following characters are not-escaped by encodeURIComponent but {@link https://tools.ietf.org/html/rfc3986 RFC 3986}\n * lists them as 'reserved' and hence needs to be percent encoded, though they have no formalized URI delimiting cases\n *\n * >   ! ' ( ) *\n *\n * Percent encoding needs to be uppercase hexadecimal as per {@link https://tools.ietf.org/html/rfc3986#section-2.1 RFC 3986 - Percent Encoding}\n *\n * @see https://tools.ietf.org/html/rfc6749#appendix-B\n * @see https://tools.ietf.org/html/rfc6749#section-2.3.1\n *\n * @param {String} value\n */\nfunction useFormURLEncode(value) {\n  return encodeURIComponent(value)\n    .replace(/%20/g, '+')\n    .replace(/[!'()*]/g, (c) => `%${c.charCodeAt(0).toString(16).toUpperCase()}`);\n}\n\n/**\n * Get a string representation for the client credentials\n *\n * @param {String} clientID\n * @param {String} clientSecret\n * @returns {String} credentials\n */\nfunction getCredentialsString(clientID, clientSecret) {\n  return `${clientID}:${clientSecret}`;\n}\n\nclass CredentialsEncoding {\n  constructor(encodingMode) {\n    this.encodingMode = encodingMode;\n  }\n\n  /**\n   * Get the authorization header used to request a valid token\n   * @param  {String} clientID\n   * @param  {String} clientSecret\n   * @return {String}              Authorization header string token\n   */\n  getAuthorizationHeaderToken(clientID, clientSecret) {\n    let encodedCredentials;\n\n    if (this.encodingMode === credentialsEncodingModeEnum.STRICT) {\n      encodedCredentials = getCredentialsString(useFormURLEncode(clientID), useFormURLEncode(clientSecret));\n    } else {\n      encodedCredentials = getCredentialsString(clientID, clientSecret);\n    }\n\n    return Buffer.from(encodedCredentials).toString(HEADER_ENCODING_FORMAT);\n  }\n}\n\nmodule.exports = {\n  CredentialsEncoding,\n  credentialsEncodingModeEnum,\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,MAAMA,sBAAsB,GAAG,QAAQ;AAEvC,MAAMC,2BAA2B,GAAG;EAClCC,MAAM,EAAE,QAAQ;EAChBC,KAAK,EAAE;AACT,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,gBAAgBA,CAACC,KAAK,EAAE;EAC/B,OAAOC,kBAAkB,CAACD,KAAK,CAAC,CAC7BE,OAAO,CAAC,MAAM,EAAE,GAAG,CAAC,CACpBA,OAAO,CAAC,UAAU,EAAGC,CAAC,IAAM,IAAGA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAACC,QAAQ,CAAC,EAAE,CAAC,CAACC,WAAW,CAAC,CAAE,EAAC,CAAC;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,oBAAoBA,CAACC,QAAQ,EAAEC,YAAY,EAAE;EACpD,OAAQ,GAAED,QAAS,IAAGC,YAAa,EAAC;AACtC;AAEA,MAAMC,mBAAmB,CAAC;EACxBC,WAAWA,CAACC,YAAY,EAAE;IACxB,IAAI,CAACA,YAAY,GAAGA,YAAY;EAClC;;EAEA;AACF;AACA;AACA;AACA;AACA;EACEC,2BAA2BA,CAACL,QAAQ,EAAEC,YAAY,EAAE;IAClD,IAAIK,kBAAkB;IAEtB,IAAI,IAAI,CAACF,YAAY,KAAKhB,2BAA2B,CAACC,MAAM,EAAE;MAC5DiB,kBAAkB,GAAGP,oBAAoB,CAACR,gBAAgB,CAACS,QAAQ,CAAC,EAAET,gBAAgB,CAACU,YAAY,CAAC,CAAC;IACvG,CAAC,MAAM;MACLK,kBAAkB,GAAGP,oBAAoB,CAACC,QAAQ,EAAEC,YAAY,CAAC;IACnE;IAEA,OAAOM,MAAM,CAACC,IAAI,CAACF,kBAAkB,CAAC,CAACT,QAAQ,CAACV,sBAAsB,CAAC;EACzE;AACF;AAEAsB,MAAM,CAACC,OAAO,GAAG;EACfR,mBAAmB;EACnBd;AACF,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}